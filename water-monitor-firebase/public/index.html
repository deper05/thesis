<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Wireless Water Quality Monitoring System</title>
  <link rel="icon" type="image/png" href="icons/drop_4633402.png"/> 
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <link rel="stylesheet" href="styles.css"/>
  
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --primary: #667eea;
      --primary-dark: #5a6fd8;
      --success: #10b981;
      --success-light: #d1fae5;
      --danger: #ef4444;
      --danger-light: #fee2e2;
      --warning: #f59e0b;
      --warning-light: #fef3c7;
      --info: #3b82f6;
      --info-light: #dbeafe;
      --purple: #8b5cf6;
      --purple-light: #ede9fe;
      --teal: #14b8a6;
      --teal-light: #ccfbf1;
      --dark: #1f2937;
      --light: #f8fafc;
      --gray-50: #f9fafb;
      --gray-100: #f8f9fa;
      --gray-200: #e9ecef;
      --gray-300: #dee2e6;
      --gray-400: #ced4da;
      --gray-500: #9ca3af;
      --gray-600: #6b7280;
      --gray-700: #4b5563;
      --gray-800: #1f2937;
      --border-radius: 0.75rem;
      --border-radius-sm: 0.5rem;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.05);
      --shadow-lg: 0 10px 25px rgba(0,0,0,0.08);
      --transition: all 0.2s ease-in-out;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-50);
      min-height: 100vh;
      color: var(--dark);
      overflow-x: hidden;
      line-height: 1.6;
    }

    /* Improved Navbar */
    .navbar {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--gray-200);
      box-shadow: var(--shadow-sm);
      padding: 0.8rem 0;
      transition: var(--transition);
    }
    
    .navbar-brand {
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--primary) !important;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .nav-link {
      font-weight: 500;
      transition: var(--transition);
      border-radius: var(--border-radius-sm);
      padding: 0.6rem 1rem !important;
      margin: 0 0.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--gray-600) !important;
    }
    
    .nav-link:hover, .nav-link:focus {
      background: var(--gray-100);
      color: var(--dark) !important;
      transform: translateY(-1px);
    }

    /* Improved Section Badge */
    .section-badge {
      background: var(--primary);
      color: white;
      padding: 0.5rem 1.25rem;
      border-radius: 2rem;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.5px;
      display: inline-block;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-sm);
    }

    /* Improved Alerts */
    #reading-alerts {
      position: sticky;
      top: 1rem;
      z-index: 100;
    }
    
    #reading-alerts .alert {
      border: 1px solid var(--gray-200);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
      background: #ffffff;
      margin-bottom: 0.75rem;
      animation: slideDown 0.3s ease-out;
      border-left: 4px solid transparent;
      padding: 1rem 1.25rem;
      transition: var(--transition);
    }
    
    #reading-alerts .alert:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }
    
    .alert-success { 
      border-left-color: var(--success); 
      background: var(--success-light);
    }
    .alert-danger { 
      border-left-color: var(--danger); 
      background: var(--danger-light);
    }
    .alert-info { 
      border-left-color: var(--info); 
      background: var(--info-light);
    }
    .alert-warning { 
      border-left-color: var(--warning); 
      background: var(--warning-light);
    }
    
    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* No Data Notification Styles */
    .no-data-notification {
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
      border-left: 4px solid var(--warning);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-sm);
    }
    
    .no-data-notification h5 {
      color: #92400e;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .no-data-reasons {
      list-style: none;
      padding-left: 0;
      margin-bottom: 0;
    }
    
    .no-data-reasons li {
      padding: 0.5rem 0;
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      color: #92400e;
    }
    
    .no-data-reasons li i {
      color: var(--warning);
      margin-top: 0.125rem;
      flex-shrink: 0;
    }
    
    .no-data-reasons li strong {
      color: #92400e;
    }

    /* Improved Carousel */
    #waterQualityCarousel {
      background: #ffffff;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--gray-200);
      margin-bottom: 2rem;
    }

    .carousel-slide-container {
      padding: 2.5rem;
    }
    
    .carousel-slide-header {
      text-align: center;
      margin-bottom: 2.5rem;
    }
    
    .carousel-slide-header h3 {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--dark);
      margin-bottom: 0.75rem;
    }
    
    .carousel-slide-header p {
      color: var(--gray-600);
      font-size: 1.1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .chart-wrapper {
      background: white;
      border-radius: var(--border-radius);
      padding: 1.75rem;
      box-shadow: var(--shadow-sm);
      height: 500px;
      border: 1px solid var(--gray-200);
    }

    /* Improved Sensor Cards */
    .sensor-card {
      background: #ffffff;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      transition: var(--transition);
      border: 1px solid var(--gray-200);
      height: 100%;
    }
    
    .sensor-card:hover {
      box-shadow: var(--shadow-lg);
      transform: translateY(-5px);
    }
    
    .sensor-card-header {
      background: var(--primary-gradient);
      padding: 2rem;
      border-bottom: none;
      color: white;
      text-align: center;
    }
    
    .sensor-card-body {
      padding: 2rem;
    }
    
    .parameter-card {
      border-radius: var(--border-radius);
      transition: var(--transition);
      border: 1px solid var(--gray-200);
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      border-left: 4px solid;
      position: relative;
      overflow: hidden;
    }
    
    .parameter-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
    }
    
    /* Color coding for parameter cards */
    .parameter-card.ph {
      border-left-color: var(--info);
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    }
    
    .parameter-card.temp {
      border-left-color: var(--warning);
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }
    
    .parameter-card.tds {
      border-left-color: var(--teal);
      background: linear-gradient(135deg, #f0fdfa 0%, #ccfbf1 100%);
    }
    
    .parameter-card.turb {
      border-left-color: var(--purple);
      background: linear-gradient(135deg, #faf5ff 0%, #e9d5ff 100%);
    }

    .good { color: var(--success); }
    .bad { color: var(--danger); }
    .stale { color: var(--warning); }

    /* Improved Carousel Navigation */
    .carousel-indicators {
      bottom: -50px;
    }
    
    .carousel-indicators button {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: var(--gray-300);
      border: none;
      margin: 0 6px;
      transition: var(--transition);
      opacity: 0.7;
    }
    
    .carousel-indicators button.active {
      background-color: var(--primary);
      opacity: 1;
      transform: scale(1.2);
    }

    .carousel-nav-labels {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      margin-top: 2rem;
      flex-wrap: wrap;
    }
    
    .carousel-nav-btn {
      background: var(--primary);
      border: 1px solid var(--primary);
      border-radius: var(--border-radius);
      padding: 1rem 1.5rem;
      min-width: 140px;
      transition: var(--transition);
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-weight: 500;
      font-size: 1rem;
      color: white !important;
    }
    
    .carousel-nav-btn:hover {
      background: var(--primary-dark);
      color: white !important;
      border-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .carousel-nav-btn.active {
      background: var(--primary-dark);
      color: white;
      border-color: var(--primary-dark);
      box-shadow: var(--shadow-lg);
    }

    /* Improved Controls - MAKE NEXT BUTTON VISIBLE */
    .carousel-control-prev, .carousel-control-next {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #ffffff;
      border: 1px solid var(--gray-300);
      opacity: 1 !important; /* Force visibility */
      visibility: visible !important;
      display: block !important;
      top: 50%;
      transform: translateY(-50%);
      transition: var(--transition);
      box-shadow: var(--shadow-sm);
    }
    
    .carousel-control-prev:hover, .carousel-control-next:hover {
      background: var(--primary);
      border-color: var(--primary);
      opacity: 1;
      transform: translateY(-50%) scale(1.05);
    }
    
    .carousel-control-prev { left: 20px; }
    .carousel-control-next { right: 20px; }

    /* Improved Map */
    #map {
      height: 500px;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--gray-200);
    }

    /* Improved Footer */
    footer {
      background: var(--dark);
      color: white;
      margin-top: 4rem;
      padding: 3rem 0 2rem;
    }
    
    footer h2 {
      font-weight: 700;
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }
    
    footer p {
      font-size: 0.875rem;
      line-height: 1.6;
      opacity: 0.9;
    }
    
    .footer-links {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    /* Improved Loading Spinner */
    .spinner-border {
      width: 3rem;
      height: 3rem;
    }
    
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 3rem;
      text-align: center;
    }

    /* REMOVE UPDATED TIMESTAMP */
    .updated-time {
      display: none !important;
    }

    /* Section spacing improvements */
    .section-spacing {
      padding: 4rem 0;
    }
    
    .section-title {
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--dark);
      font-size: 2.25rem;
    }
    
    .section-subtitle {
      color: var(--gray-600);
      margin-bottom: 2rem;
      font-size: 1.125rem;
    }

    /* Card improvements */
    .card-hover {
      transition: var(--transition);
    }
    
    .card-hover:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
    }

    /* Button improvements */
    .btn {
      border-radius: var(--border-radius-sm);
      font-weight: 500;
      transition: var(--transition);
      padding: 0.6rem 1.25rem;
    }
    
    .btn-primary {
      background: var(--primary);
      border-color: var(--primary);
    }
    
    .btn-primary:hover {
      background: var(--primary-dark);
      border-color: var(--primary-dark);
      transform: translateY(-1px);
    }

    /* Info card improvements */
    .info-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem;
      border-radius: var(--border-radius);
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      transition: var(--transition);
    }
    
    .info-card:hover {
      background: white;
      box-shadow: var(--shadow-sm);
    }
    
    .info-card .sensor-icon {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .info-card .sensor-icon img {
      width: 40px;
      height: 40px;
    }
    
    .info-card .sensor-icon strong {
      font-size: 1rem;
      color: var(--gray-700);
    }
    
    .info-card .sensor-value {
      text-align: right;
    }
    
    .info-card .sensor-value p {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
    }
    
    .info-card .sensor-value small {
      color: var(--gray-500);
      font-size: 0.875rem;
    }

    /* Large monitor specific styles */
    @media (min-width: 1400px) {
      .parameter-card {
        padding: 2rem;
      }
      
      .carousel-slide-container {
        padding: 3rem;
      }
      
      .container {
        max-width: 1400px;
      }
    }

    /* Responsive Adjustments */
    @media (max-width: 1200px) {
      .carousel-slide-header h3 { font-size: 1.5rem; }
      .section-title { font-size: 2rem; }
    }
    
    @media (max-width: 992px) {
      .carousel-slide-header h3 { font-size: 1.375rem; }
      .chart-wrapper { height: 450px; }
      .parameter-card {
        padding: 1.25rem;
      }
      .carousel-slide-container { padding: 2rem; }
      .section-title { font-size: 1.75rem; }
    }
    
    @media (max-width: 768px) {
      .carousel-slide-container { padding: 1.5rem; }
      .chart-wrapper { height: 400px; padding: 1.25rem; }
      .carousel-nav-btn { min-width: 120px; padding: 0.75rem 1rem; }
      .carousel-control-prev, .carousel-control-next { 
        width: 45px; 
        height: 45px; 
      }
      .carousel-control-prev { left: 10px; }
      .carousel-control-next { right: 10px; }
      .section-spacing {
        padding: 3rem 0;
      }
      .section-title { font-size: 1.5rem; }
      .section-subtitle { font-size: 1rem; }
      .info-card {
        padding: 1rem;
      }
      .info-card .sensor-icon img {
        width: 35px;
        height: 35px;
      }
    }
    
    @media (max-width: 576px) {
      .carousel-nav-btn { min-width: 100px; padding: 0.75rem; font-size: 0.875rem; }
      .carousel-slide-header h3 { font-size: 1.25rem; }
      .section-badge { font-size: 0.7rem; padding: 0.3rem 0.75rem; }
      .sensor-card-header {
        padding: 1.5rem;
      }
      .sensor-card-body {
        padding: 1.5rem;
      }
      .footer-links {
        flex-direction: column;
        gap: 0.5rem;
      }
      .info-card {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }
      .info-card .sensor-value {
        text-align: left;
        width: 100%;
      }
    }

    :root {
  --carousel-height: 22vh;
  --carousel-min-height: 120px;
  --carousel-max-height: 240px;
  --header-height: 48px;
  --mobile-height: 44vh;
  --mobile-min-height: 200px;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  STICKY CAROUSEL  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sticky-carousel-container{
  position:fixed;left:0;bottom:0;width:100%;
  height:var(--carousel-height);
  min-height:var(--carousel-min-height);
  max-height:var(--carousel-max-height);
  background:linear-gradient(180deg,rgba(255,255,255,.98),rgba(250,250,250,.98));
  border-top:1px solid rgba(16,24,40,.06);
  box-shadow:0 -6px 28px rgba(12,18,30,.08);
  z-index:1200;transition:transform .26s ease,height .26s ease;
  overflow:hidden;font-family:system-ui,-apple-system,sans-serif;
}
.sticky-carousel-container.minimized{
  transform:translateY(calc(100% - var(--header-height)));
  height:var(--header-height);
}

/* Header */
.sticky-carousel-container .carousel-header{
  height:var(--header-height);display:flex;align-items:center;justify-content:space-between;
  padding:0 14px;border-bottom:1px solid rgba(16,24,40,.04);
  cursor:pointer;user-select:none;position:relative;
}
.sticky-carousel-container .carousel-title{
  display:flex;align-items:center;gap:10px;margin:0;
  font-weight:700;font-size:14px;color:#2b2f36;
}
.sticky-carousel-container .live-indicator{
  width:9px;height:9px;border-radius:50%;background:#22c55e;
  animation:sc-pulse 1.8s infinite;
}
@keyframes sc-pulse{0%,100%{opacity:1}50%{opacity:.6}}

.sticky-carousel-container .last-updated{
  position:absolute;left:50%;transform:translateX(-50%);
  font-size:11px;color:#6b7280;font-weight:500;
  display:flex;align-items:center;gap:6px;
}
.sticky-carousel-container .refresh-spinner{
  width:12px;height:12px;border:2px solid #e5e7eb;
  border-top-color:#3b82f6;border-radius:50%;
  animation:spin 0.8s linear infinite;display:none;
}
.sticky-carousel-container.refreshing .refresh-spinner{display:block;}
@keyframes spin{to{transform:rotate(360deg)}}

/* Controls */
.sticky-carousel-container .controls{display:flex;align-items:center;gap:8px;}
.sticky-carousel-container .nav-btn{
  background:#fff;border:1px solid rgba(16,24,40,.06);
  height:36px;width:36px;border-radius:8px;
  display:flex;align-items:center;justify-content:center;
  font-weight:700;font-size:14px;cursor:pointer;
  transition:all .2s ease;
}
.sticky-carousel-container .nav-btn:hover:not(:disabled){
  background:#f9fafb;border-color:#3b82f6;transform:scale(1.05);
}
.sticky-carousel-container .nav-btn:active:not(:disabled){
  transform:scale(0.95);
}
.sticky-carousel-container .nav-btn:disabled{opacity:.45;cursor:not-allowed;}
.sticky-carousel-container .page-indicator{
  min-width:56px;text-align:center;font-weight:700;color:#374151;font-size:13px;
}

/* Wrapper / Track */
.sticky-carousel-container .carousel-wrapper{
  height:calc(100% - var(--header-height));overflow:hidden;position:relative;
}
.sticky-carousel-container .carousel-track{
  display:flex;height:100%;transition:transform .36s ease;gap:0;
  will-change:transform;
}
.sticky-carousel-container .carousel-track.dragging{
  transition:none;
}

/* â”€â”€â”€â”€â”€â”€  PAGE (one slide)  â”€â”€â”€â”€â”€â”€ */
.sticky-carousel-container .barangay-page{
  min-width:100%;width:100%;flex-shrink:0;box-sizing:border-box;
  display:flex;gap:12px;align-items:stretch;
  padding:10px 12px;overflow-y:auto;overflow-x:hidden;
}

/* Barangay card */
.sticky-carousel-container .barangay-card{
  flex:0 0 34%;background:#fff;border-radius:12px;
  padding:10px 12px;display:flex;flex-direction:column;gap:6px;
  border:1px solid rgba(16,24,40,.04);min-width:0;
  transition:border-color .3s ease;
}
.sticky-carousel-container .barangay-card.alert{
  border-color:#fbbf24;border-width:2px;
  animation:alert-pulse 2s infinite;
}
@keyframes alert-pulse{0%,100%{border-color:#fbbf24}50%{border-color:#f59e0b}}

.sticky-carousel-container .barangay-card h4{
  margin:0;font-size:16px;font-weight:800;color:#1f2937;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.sticky-carousel-container .barangay-card p{
  margin:0;font-size:13px;color:#4b5563;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.sticky-carousel-container .barangay-timestamp{
  display:flex;flex-direction:column;gap:2px;font-size:12px;color:#374151;
  margin-top:auto;
}
.sticky-carousel-container .timestamp-label{font-weight:600;color:#6b7280;}
.sticky-carousel-container .timestamp-value{font-weight:700;color:#1f2937;}
.sticky-carousel-container .timestamp-value.stale{color:#d97706;font-weight:700;}

/* Alert badge */
.sticky-carousel-container .alert-badge{
  display:inline-flex;align-items:center;gap:4px;
  background:#fef3c7;color:#92400e;font-size:11px;font-weight:700;
  padding:3px 8px;border-radius:12px;margin-top:4px;
  align-self:flex-start;
}

/* Sensors grid */
.sticky-carousel-container .sensors-grid{
  flex:1;display:grid;grid-template-columns:repeat(4,1fr);
  gap:10px;min-width:0;
}
.sticky-carousel-container .compact-sensor-card{
  border-radius:10px;padding:8px;background:#fff;
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  border:1px solid rgba(16,24,40,.04);min-width:0;
  transition:transform .2s ease,box-shadow .2s ease;
  position:relative;
}
.sticky-carousel-container .sensor-label-compact{
  font-size:12px;color:#4b5563;font-weight:600;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:100%;text-align:center;
}
/* INCREASE FONT SIZE FOR FETCHED DATA */
.sticky-carousel-container .sensor-value-compact{
  font-size:24px !important;font-weight:900;color:#1f2937;
}
.sticky-carousel-container .sensor-unit-compact{
  font-size:11px;color:#6b7280;font-weight:500;
}

/* Status colours */
.sticky-carousel-container .compact-sensor-card.good{background:#ecfdf5;border-color:#a7f3d0;}
.sticky-carousel-container .compact-sensor-card.bad{
  background:#fff7f2;border-color:#fdba8c;
  animation:sensor-alert 1.5s infinite;
}
@keyframes sensor-alert{0%,100%{box-shadow:0 0 0 0 rgba(251,146,60,.4)}50%{box-shadow:0 0 0 4px rgba(251,146,60,0)}}

.sticky-carousel-container .compact-sensor-card.missing{background:#f8fafc;color:#94a3b8;}
.sticky-carousel-container .compact-sensor-card.stale{background:#fffbeb;}

/* Loading */
.sticky-carousel-container .carousel-loading{
  display:flex;align-items:center;justify-content:center;gap:10px;
  width:100%;height:100%;color:#5b6b84;font-size:14px;
  flex-direction:column;
}

/* Error state */
.sticky-carousel-container .carousel-error{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  gap:12px;width:100%;height:100%;padding:20px;text-align:center;
}
.sticky-carousel-container .error-icon{
  width:48px;height:48px;color:#ef4444;
}
.sticky-carousel-container .error-message{
  font-size:14px;color:#374151;font-weight:600;
}
.sticky-carousel-container .error-details{
  font-size:12px;color:#6b7280;
}
.sticky-carousel-container .retry-btn{
  background:#3b82f6;color:#fff;border:none;
  padding:8px 16px;border-radius:8px;font-weight:600;
  cursor:pointer;font-size:13px;transition:all .2s ease;
}
.sticky-carousel-container .retry-btn:hover{
  background:#2563eb;transform:scale(1.05);
}
.sticky-carousel-container .retry-btn:active{
  transform:scale(0.95);
}

/* Summary view toggle */
.sticky-carousel-container .view-toggle{
  background:#fff;border:1px solid rgba(16,24,40,.06);
  height:36px;padding:0 12px;border-radius:8px;
  font-size:12px;font-weight:600;cursor:pointer;
  transition:all .2s ease;
}
.sticky-carousel-container .view-toggle:hover{
  background:#f9fafb;border-color:#3b82f6;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  MOBILE  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width:640px){
  .sticky-carousel-container{
    height:var(--mobile-height);
    min-height:var(--mobile-min-height);
  }
  .sticky-carousel-container.minimized{height:var(--header-height);}
  .sticky-carousel-container .barangay-page{
    flex-direction:column;padding:12px;gap:12px;
  }
  .sticky-carousel-container .barangay-card{
    flex:none;width:100%;padding:12px;
  }
  .sticky-carousel-container .barangay-card h4{font-size:18px;}
  .sticky-carousel-container .barangay-card p{font-size:14px;}
  .sticky-carousel-container .sensors-grid{
    grid-template-columns:repeat(2,1fr);
    grid-auto-rows:minmax(90px,auto);gap:12px;
  }
  .sticky-carousel-container .compact-sensor-card{padding:12px;}
  .sticky-carousel-container .sensor-value-compact{font-size:24px;}
  .sticky-carousel-container .sensor-label-compact{font-size:13px;}
  .sticky-carousel-container .sensor-unit-compact{font-size:12px;}
  .sticky-carousel-container .last-updated{
    position:static;transform:none;margin-top:4px;
  }
  .sticky-carousel-container .carousel-header{
    flex-wrap:wrap;height:auto;min-height:var(--header-height);
  }
}
@media (max-width:480px){
  .sticky-carousel-container .carousel-header{padding:0 10px;}
  .sticky-carousel-container .nav-btn{width:32px;height:32px;font-size:13px;}
  .sticky-carousel-container .page-indicator{font-size:12px;min-width:48px;}
}

/* Landscape mobile */
@media (max-height:500px) and (orientation:landscape){
  .sticky-carousel-container{
    height:70vh;min-height:280px;
  }
  .sticky-carousel-container .sensors-grid{
    grid-template-columns:repeat(4,1fr);
  }
}

/* Screen reader only */
.sr-only{
  position:absolute;width:1px;height:1px;padding:0;margin:-1px;
  overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0;
}
/* === REDESIGNED CAROUSEL */


.clickable-parameter {
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}
.clickable-parameter:hover {
  background-color: #e3f2fd !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}
.chart-container-collapse {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease;
  background: #f8f9fa;
  border-radius: 0 0 12px 12px;
  margin-top: -10px;
}
.chart-container-collapse.open {
  max-height: 300px;
  padding: 15px;
  border: 1px solid #dee2e6;
}
.parameter-row.active .clickable-parameter {
  border-bottom: 2px solid #0d6efd;
  border-radius: 12px 12px 0 0;
}

  </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light fixed-top">
  <div class="container">
    <a class="navbar-brand fw-bold" href="#">
      <i class="fas fa-tint me-2"></i>Water Monitor
    </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse justify-content-end" id="navbarNav">
      <ul class="navbar-nav align-items-center">
        <li class="nav-item me-2">
          <a class="nav-link" href="#main-carousel-section">
            <i class="fas fa-chart-line me-1"></i> Dashboard
          </a>
        </li>
        <li class="nav-item me-2">
          <a class="nav-link" href="#map-section">
            <i class="fas fa-map-marked-alt me-1"></i> Map
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="admin.html">
            <i class="fas fa-user-shield me-1"></i> Admin Panel
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="container mt-5 pt-5">
  <div id="reading-alerts" class="container mt-4"></div>

  <!-- No Data Notification Container -->
  <div id="no-data-notification" class="container mt-4" style="display: none;"></div>

  <div class="container-fluid py-4 min-vh-100">
    <div class="row justify-content-center">

      <!-- Enhanced Carousel Section -->
      <section id="main-carousel-section" class="section-spacing">
        <div class="container">
          <div class="text-center mb-5">
            <span class="section-badge">
              WATER QUALITY DASHBOARD
            </span>
            <h2 class="section-title">Interactive Data Viewer</h2>
            <p class="section-subtitle">Real-time monitoring of water quality parameters across all stations</p>
          </div>

          <div id="waterQualityCarousel" class="carousel slide" data-bs-ride="false" data-bs-interval="false">
            
            <!-- Carousel Indicators -->
            <div class="carousel-indicators">
              <button type="button" data-bs-target="#waterQualityCarousel" data-bs-slide-to="0" class="active" aria-current="true" aria-label="All Readings"></button>
              <button type="button" data-bs-target="#waterQualityCarousel" data-bs-slide-to="1" aria-label="pH Chart"></button>
              <button type="button" data-bs-target="#waterQualityCarousel" data-bs-slide-to="2" aria-label="Temperature Chart"></button>
              <button type="button" data-bs-target="#waterQualityCarousel" data-bs-slide-to="3" aria-label="TDS Chart"></button>
              <button type="button" data-bs-target="#waterQualityCarousel" data-bs-slide-to="4" aria-label="Turbidity Chart"></button>
            </div>

            <!-- Carousel Inner -->
            <div class="carousel-inner">
              
              <!-- Slide 1: All Current Readings -->
              <div class="carousel-item active">
                <div class="carousel-slide-container">
                  <div class="carousel-slide-header">
                    <h3>Live Water Quality Parameters</h3>
                    <p>Current readings from all monitoring stations</p>
                  </div>
                  <div id="carousel-sensor-cards" class="row g-4">
                    <!-- Sensor cards will be dynamically inserted here -->
                    <div class="col-12">
                      <div class="loading-container">
                        <div class="spinner-border text-primary" role="status">
                          <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3 text-muted">Loading monitoring units...</p>
                      </div>
                    </div>
                  </div>
                  <!-- REMOVED: Updated timestamp element -->
                </div>
              </div>

              <!-- Slide 2: pH Chart -->
              <div class="carousel-item">
                <div class="carousel-slide-container">
                  <div class="carousel-slide-header">
                    <h3>pH Level History</h3>
                    <p>Track pH levels across all monitoring stations over time</p>
                  </div>
                  <div class="chart-wrapper">
                    <canvas id="carouselPhChart"></canvas>
                  </div>
                </div>
              </div>

              <!-- Slide 3: Temperature Chart -->
              <div class="carousel-item">
                <div class="carousel-slide-container">
                  <div class="carousel-slide-header">
                    <h3>Temperature History</h3>
                    <p>Monitor water temperature trends and variations</p>
                  </div>
                  <div class="chart-wrapper">
                    <canvas id="carouselTempChart"></canvas>
                  </div>
                </div>
              </div>

              <!-- Slide 4: TDS Chart -->
              <div class="carousel-item">
                <div class="carousel-slide-container">
                  <div class="carousel-slide-header">
                    <h3>Total Dissolved Solids History</h3>
                    <p>Analyze TDS concentration patterns</p>
                  </div>
                  <div class="chart-wrapper">
                    <canvas id="carouselTdsChart"></canvas>
                  </div>
                </div>
              </div>

              <!-- Slide 5: Turbidity Chart -->
              <div class="carousel-item">
                <div class="carousel-slide-container">
                  <div class="carousel-slide-header">
                    <h3>Turbidity History</h3>
                    <p>Observe water clarity and turbidity measurements</p>
                  </div>
                  <div class="chart-wrapper">
                    <canvas id="carouselTurbChart"></canvas>
                  </div>
                </div>
              </div>

            </div>

            <!-- Carousel Controls - NEXT BUTTON NOW VISIBLE -->
            <button class="carousel-control-prev" type="button" data-bs-target="#waterQualityCarousel" data-bs-slide="prev">
              <span class="carousel-control-prev-icon" aria-hidden="true"></span>
              <span class="visually-hidden">Previous</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#waterQualityCarousel" data-bs-slide="next">
              <span class="carousel-control-next-icon" aria-hidden="true"></span>
              <span class="visually-hidden">Next</span>
            </button>

            <!-- Enhanced Navigation Labels -->
            <div class="carousel-nav-labels">
              <button class="carousel-nav-btn active" data-bs-target="#waterQualityCarousel" data-bs-slide-to="0">
                <i class="fas fa-list"></i> All Readings
              </button>
              <button class="carousel-nav-btn" data-bs-target="#waterQualityCarousel" data-bs-slide-to="1">
                <i class="fas fa-tint"></i> pH Level
              </button>
              <button class="carousel-nav-btn" data-bs-target="#waterQualityCarousel" data-bs-slide-to="2">
                <i class="fas fa-thermometer-half"></i> Temperature
              </button>
              <button class="carousel-nav-btn" data-bs-target="#waterQualityCarousel" data-bs-slide-to="3">
                <i class="fas fa-flask"></i> TDS
              </button>
              <button class="carousel-nav-btn" data-bs-target="#waterQualityCarousel" data-bs-slide-to="4">
                <i class="fas fa-water"></i> Turbidity
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- Enhanced Map Section -->
      <section id="map-section" class="section-spacing">
        <div class="container">
          <div class="text-center mb-4">
            <span class="section-badge">
              SENSOR LOCATIONS
            </span>
            <h2 class="section-title">Sensor Network Map</h2>
            <p class="section-subtitle">Visual representation of all monitoring stations and their status</p>
          </div>
          <div id="map"></div>
        </div>
      </section>
    </div>
  </div>
</div>

<!-- Enhanced Footer -->
<footer>
  <div class="container">
    <div class="row align-items-center">
      <div class="col-lg-8">
        <h2 class="text-white mb-3">
          <i class="fas fa-tint me-2"></i> Wireless Water Quality Monitoring System
        </h2>
        <p class="text-white mb-0">
          Real-time IoT-based water quality monitoring using advanced sensors to track pH, temperature, turbidity, and total dissolved solids (TDS). Our cloud-connected dashboard enables instant pollution detection and rapid response, ensuring safe water for communities and protecting the environment.
        </p>
      </div>
      <div class="col-lg-4 text-lg-end mt-4 mt-lg-0">
        <div class="footer-links">
          <a href="#main-carousel-section" class="btn btn-outline-light btn-sm">
            <i class="fas fa-chart-line me-1"></i> Dashboard
          </a>
          <a href="#map-section" class="btn btn-outline-light btn-sm">
            <i class="fas fa-map-marked-alt me-1"></i> Map
          </a>
          <a href="admin.html" class="btn btn-light btn-sm">
            <i class="fas fa-user-shield me-1"></i> Admin
          </a>
        </div>
      </div>
    </div>
    <div class="text-center mt-4 pt-3 border-top border-light border-opacity-25">
      <p class="mb-0">&copy; 2023 Water Monitor. All rights reserved.</p>
      </div>
    </div>
  </footer>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
    const firebaseConfig = {
            apiKey: "AIzaSyDQL-6PMlYVED2I2KpYISiDaf4huUg9tZw",
            authDomain: "thesis-1bda3.firebaseapp.com",
            databaseURL: "https://thesis-1bda3-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "thesis-1bda3",
            storageBucket: "thesis-1bda3.firebasestorage.app",
            messagingSenderId: "509024706594",
            appId: "1:509024706594:web:4823234418f6a1d9b66a7b"
        };
    const app = firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
</script>

<script>
// All your existing JavaScript code remains exactly the same
// Only updating the sensor card HTML generation in the updateCarouselSensorCards function

const dbRef = database.ref();

// âœ… Define alignTimestamp at the very top before everything else
function alignTimestamp(ts) {
  if (!ts) return ts;
  try {
    const [datePart, timePart] = ts.split('_');
    if (!datePart || !timePart) return ts;
    
    const [year, month, day] = datePart.split('-');
    const timeComponents = timePart.split(':');
    const hour = timeComponents[0];
    const minute = timeComponents[1] || '00';
    
    // Round to nearest 30 minutes (0 or 30)
    const roundedMinute = Math.round(parseInt(minute) / 30) * 30;
    const paddedMinute = String(roundedMinute % 60).padStart(2, '0');
    
    // Handle hour overflow (e.g., 14:58 rounds to 15:00)
    let finalHour = parseInt(hour);
    if (roundedMinute >= 60) {
      finalHour = (finalHour + 1) % 24;
    }
    const paddedHour = String(finalHour).padStart(2, '0');
    
    return `${datePart}_${paddedHour}:${paddedMinute}:00`;
  } catch (error) {
    console.error('Error aligning timestamp:', ts, error);
    return ts;
  }
}

const chartConfig = (label, min, max, step) => ({
  type: 'line',
  data: {
    labels: [],
    datasets: []
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    animation: { 
      duration: 800, 
      easing: 'easeInOutQuad' 
    },
    elements: {
      line: {
        tension: 0.3,
        spanGaps: true
      }
    },
    scales: {
      y: { 
        min, 
        max, 
        ticks: { 
          stepSize: step,
          autoSkip: false
        } 
      },
      x: { 
  ticks: { 
    maxRotation: 45, 
    minRotation: 45,
    autoSkip: true,
    maxTicksLimit: 12 // Adjust this number to control how many labels show
  } 
}
    },
    plugins: {
      title: { display: true, text: label + " vs Time" },
      legend: { display: true },
      tooltip: {
        callbacks: {
          title: (context) => `Time: ${context[0].label}`,
          label: (context) => `${context.dataset.label}: ${context.parsed.y}`
        }
      }
    }
  }
});

const charts = {};
let carouselCharts = {};
let unitMetadata = {};
let lastKnownData = {};

let lastUpdate = 0;
const UPDATE_COOLDOWN = 30000;

const STALE_THRESHOLD = 30 * 60 * 1000;

// Track consecutive no-data fetches
let consecutiveNoDataCount = 0;
const NO_DATA_THRESHOLD = 3; // Show notification after 3 consecutive no-data fetches

// Update timestamp function
function updateLastUpdateTime() {
  const now = Date.now();
  const diff = now - lastUpdate;
  const minutes = Math.floor(diff / 60000);
  const seconds = Math.floor((diff % 60000) / 1000);
  
  let displayText;
  if (minutes > 0) {
    displayText = `${minutes}m ${seconds}s`;
  } else {
    displayText = `${seconds}s`;
  }
  
  const element = document.getElementById('last-update-time');
  if (element) {
    element.textContent = displayText;
  }
}

// Update timestamp every second
setInterval(updateLastUpdateTime, 1000);

function loadCachedData() {
  try {
    const cached = localStorage.getItem('lastKnownWaterData');
    if (cached) {
      lastKnownData = JSON.parse(cached);
      console.log('ðŸ“¦ Loaded cached data from previous session');
    }
  } catch (error) {
    console.error('Error loading cached data:', error);
  }
}

function saveCachedData() {
  try {
    localStorage.setItem('lastKnownWaterData', JSON.stringify(lastKnownData));
  } catch (error) {
    console.error('Error saving cached data:', error);
  }
}

function showNoDataNotification() {
  const notificationContainer = document.getElementById('no-data-notification');
  if (!notificationContainer) return;

  notificationContainer.innerHTML = `
    <div class="no-data-notification">
      <h5><i class="fas fa-exclamation-triangle"></i> No New Data Received</h5>
      <p class="mb-3">The system is not receiving new sensor readings. Displaying cached data from previous session.</p>
      <h6 class="mb-2">Possible reasons:</h6>
      <ul class="no-data-reasons">
        <li>
          <i class="fas fa-wifi"></i>
          <div>
            <strong>Network Connectivity</strong><br>
            Check if sensors have internet connection or if there's a network outage
          </div>
        </li>
        <li>
          <i class="fas fa-battery-quarter"></i>
          <div>
            <strong>Power Issues</strong><br>
            Sensors may be offline due to battery depletion or power supply problems
          </div>
        </li>
        <li>
          <i class="fas fa-microchip"></i>
          <div>
            <strong>Hardware Malfunction</strong><br>
            Sensor hardware might be damaged or malfunctioning
          </div>
        </li>
        <li>
          <i class="fas fa-cloud"></i>
          <div>
            <strong>Firebase Service</strong><br>
            Firebase database service might be experiencing issues
          </div>
        </li>
        <li>
          <i class="fas fa-code"></i>
          <div>
            <strong>Software Issues</strong><br>
            Sensor firmware or data transmission software might need updating
          </div>
        </li>
      </ul>
      <div class="mt-3">
        <small class="text-muted">
          <i class="fas fa-clock"></i> Last successful data fetch: ${lastUpdate ? new Date(lastUpdate).toLocaleString() : 'Never'}
        </small>
      </div>
    </div>
  `;
  notificationContainer.style.display = 'block';
}

function hideNoDataNotification() {
  const notificationContainer = document.getElementById('no-data-notification');
  if (notificationContainer) {
    notificationContainer.style.display = 'none';
    notificationContainer.innerHTML = '';
  }
  consecutiveNoDataCount = 0;
}

function initCharts(unitIds) {
    const chartElements = ['phChart', 'tempChart', 'turbChart', 'tdsChart'];
    const chartLabels = {
        'phChart': "pH",
        'tempChart': "Temp",
        'turbChart': "Turb",
        'tdsChart': "TDS"
    };
    const chartRanges = {
        'phChart': [0, 14, 1],
        'tempChart': [0, 40, 2],
        'turbChart': [-2000, 2000, 200],
        'tdsChart': [0, 2000, 100]
    };
    const colors = ['red', 'blue', 'green', 'purple', 'orange', 'brown', 'pink', 'teal'];

    for (const chartElemId of chartElements) {
        if (!charts[chartElemId]) {
            const config = chartConfig(chartLabels[chartElemId], ...chartRanges[chartElemId]);
            config.data.datasets = unitIds.map((unitId, index) => ({
                label: unitMetadata[unitId] ? unitMetadata[unitId].name : unitId,
                borderColor: colors[index % colors.length],
                fill: false,
                data: []
            }));
            const canvas = document.getElementById(chartElemId);
            if (canvas) {
              charts[chartElemId] = new Chart(canvas, config);
            }
        } else {
            const existingChart = charts[chartElemId];
            const newDatasets = unitIds.map((unitId, index) => {
                const existingDataset = existingChart.data.datasets.find(ds => ds.label === (unitMetadata[unitId] ? unitMetadata[unitId].name : unitId));
                
                return {
                    label: unitMetadata[unitId] ? unitMetadata[unitId].name : unitId,
                    borderColor: colors[index % colors.length],
                    fill: false,
                    data: existingDataset ? existingDataset.data : []
                };
            });
            existingChart.data.datasets = newDatasets;
            existingChart.update();
        }
    }
} 

// Initialize carousel charts
function initCarouselCharts(unitIds) {
  const chartConfigs = {
    carouselPhChart: { label: 'pH Level', min: 0, max: 14, step: 1 },
    carouselTempChart: { label: 'Temperature (Â°C)', min: 0, max: 40, step: 2 },
    carouselTdsChart: { label: 'TDS (ppm)', min: 0, max: 2000, step: 100 },
    carouselTurbChart: { label: 'Turbidity (NTU)', min: -2000, max: 2000, step: 200 }
  };

  const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a'];

  Object.entries(chartConfigs).forEach(([canvasId, config]) => {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    if (!carouselCharts[canvasId]) {
      carouselCharts[canvasId] = new Chart(canvas, {
        type: 'line',
        data: {
          labels: [],
          datasets: unitIds.map((unitId, index) => ({
            label: unitMetadata[unitId] ? unitMetadata[unitId].name : unitId,
            borderColor: colors[index % colors.length],
            backgroundColor: colors[index % colors.length] + '20',
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            data: []
          }))
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 800, easing: 'easeInOutQuad' },
          elements: {
            line: { tension: 0.4, spanGaps: true },
            point: { radius: 4, hoverRadius: 6 }
          },
          scales: {
            y: {
              min: config.min,
              max: config.max,
              ticks: { stepSize: config.step },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            },
            x: {
              ticks: { maxRotation: 45, minRotation: 45 },
              grid: { display: false }
            }
          },
          plugins: {
            title: { display: true, text: config.label + ' Over Time', font: { size: 16, weight: 'bold' } },
            legend: { display: true, position: 'top' },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              padding: 12,
              titleFont: { size: 14 },
              bodyFont: { size: 13 }
            }
          }
        }
      });
    }
  });
}

// Update carousel charts with data
function updateCarouselCharts(unitIds, timestamps, fetchedData) {
  const timeLabels = timestamps.map(formatTimestamp);

  // Update each chart
  Object.keys(carouselCharts).forEach(chartId => {
    const chart = carouselCharts[chartId];
    chart.data.labels = timeLabels;

    // Determine metric type
    let metricKey = '';
    if (chartId.includes('Ph')) metricKey = 'ph';
    else if (chartId.includes('Temp')) metricKey = 'temperature';
    else if (chartId.includes('Tds')) metricKey = 'tds';
    else if (chartId.includes('Turb')) metricKey = 'turbidity';

    // Create datasets for each unit
    chart.data.datasets = unitIds.map((unitId, index) => {
      const suffix = unitId.split('_').pop();
      const existingDataset = chart.data.datasets[index] || {};
      
      const data = timestamps.map(alignedTs => {
        if (!fetchedData[unitId]) return null;
        
        for (const originalTs in fetchedData[unitId]) {
          if (alignTimestamp(originalTs) === alignedTs) {
            const reading = fetchedData[unitId][originalTs];
            const value = reading[`${metricKey}_${suffix}`];
            return typeof value === 'number' && !isNaN(value) ? value : null;
          }
        }
        return null;
      });

      return {
        ...existingDataset,
        label: unitMetadata[unitId] ? unitMetadata[unitId].name : unitId,
        data: data
      };
    });

    chart.update();
  });
}

// Update carousel sensor cards - Colorful design with background on station header
function updateCarouselSensorCards(unitIds, latestReadings) {
  const container = document.getElementById('carousel-sensor-cards');
  if (!container) return;

  container.innerHTML = '';

  if (unitIds.length === 0) {
    container.innerHTML = '<div class="col-12 text-center"><p class="text-muted">No monitoring units available</p></div>';
    return;
  }

  const limits = {
    ph: { min: 6.5, max: 8.5 },
    temp: { min: 15, max: 35 },
    turb: { max: 5 },
    tds: { max: 500 }
  };

  unitIds.forEach(unitId => {
    const unit = unitMetadata[unitId];
    const latest = latestReadings[unitId] || {};
    const { ph, temp, turb, tds, timestamp } = latest;
    const isStale = isStaleTimestamp(timestamp);

    const cardHtml = `
      <div class="col-lg-6 mb-4">
        <div class="card sensor-card">
          <div class="card-body">
            <h5 class="text-center fw-bold">${unit?.name || unitId}</h5>
            <p class="text-center text-muted mb-4">${unit?.description || ''}</p>

            <div class="info-card">
              <div class="sensor-icon">
                <img src="icons/drop_3335855.png" alt="pH Level">
                <strong>pH Level</strong>
              </div>
              <div class="sensor-value">
                <p class="${ph !== null ? (ph >= limits.ph.min && ph <= limits.ph.max ? 'good' : 'bad') : ''} ${isStale ? 'stale' : ''}">${ph !== null ? ph : '--'}</p>
                <small class="${isStale ? 'stale' : ''}">${timestamp ? formatTimestamp(timestamp) : ''}</small>
              </div>
            </div>

            <div class="info-card">
              <div class="sensor-icon">
                <img src="icons/hot-temperature_4850456.png" alt="Temperature">
                <strong>Temperature</strong>
              </div>
              <div class="sensor-value">
                <p class="${temp !== null ? (temp >= limits.temp.min && temp <= limits.temp.max ? 'good' : 'bad') : ''} ${isStale ? 'stale' : ''}">${temp !== null ? temp + ' Â°C' : '--'}</p>
                <small class="${isStale ? 'stale' : ''}">${timestamp ? formatTimestamp(timestamp) : ''}</small>
              </div>
            </div>

            <div class="info-card">
              <div class="sensor-icon">
                <img src="icons/water-pollution_18270394.png" alt="TDS">
                <strong>TDS</strong>
              </div>
              <div class="sensor-value">
                <p class="${tds !== null ? (tds <= limits.tds.max ? 'good' : 'bad') : ''} ${isStale ? 'stale' : ''}">${tds !== null ? tds + ' ppm' : '--'}</p>
                <small class="${isStale ? 'stale' : ''}">${timestamp ? formatTimestamp(timestamp) : ''}</small>
              </div>
            </div>

            <div class="info-card">
              <div class="sensor-icon">
                <img src="icons/research_14150783.png" alt="Turbidity">
                <strong>Turbidity</strong>
              </div>
              <div class="sensor-value">
                <p class="${turb !== null ? (turb <= limits.turb.max ? 'good' : 'bad') : ''} ${isStale ? 'stale' : ''}">${turb !== null ? turb + ' NTU' : '--'}</p>
                <small class="${isStale ? 'stale' : ''}">${timestamp ? formatTimestamp(timestamp) : ''}</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;

    container.innerHTML += cardHtml;
  });
}

function formatTimestamp(ts) {
  if (!ts) return "";
  return ts.replace("_", " ").replace(/(\d{2})-(\d{2})/, "$1:$2");
}

function isStaleTimestamp(ts) {
  if (!ts) return false;
  try {
    const [datePart, timePart] = ts.split('_');
    const [year, month, day] = datePart.split('-');
    const [hour, minute, second] = timePart.split(':');
    const timestamp = new Date(year, month - 1, day, hour, minute, second);
    return (Date.now() - timestamp.getTime()) > STALE_THRESHOLD;
  } catch (error) {
    return false;
  }
}

function setStatusColor(element, value, min, max, isStale = false) {
  if (!element || isNaN(value)) return;
  element.classList.remove('good', 'bad', 'stale');
  
  if (isStale) {
    element.classList.add('stale');
  } else if (value >= min && value <= max) {
    element.classList.add('good');
  } else {
    element.classList.add('bad');
  }
}

async function fetchData() {
  try {
    const unitsMetadataSnapshot = await dbRef.child('unitsMetadata').once('value');
    unitMetadata = unitsMetadataSnapshot.val() || {};
    const unitIds = Object.keys(unitMetadata).sort();

    const fetchedData = {};
    let hasNewData = false;
    
    for (const unitId of unitIds) {
      try {
        const response = await fetch(`https://thesis-1bda3-default-rtdb.asia-southeast1.firebasedatabase.app/${unitId}.json`);
        const data = await response.json();
        
        if (data && typeof data === 'object') {
          const filteredData = {};
          for (const key in data) {
            if (key !== 'initialized' && key !== 'timestamp') {
              filteredData[key] = data[key];
            }
          }
          
          if (Object.keys(filteredData).length > 0) {
            fetchedData[unitId] = {
              ...(lastKnownData[unitId] || {}),
              ...filteredData
            };
            lastKnownData[unitId] = fetchedData[unitId];
            hasNewData = true;
          } else {
            fetchedData[unitId] = lastKnownData[unitId] || null;
            console.log(`Unit ${unitId}: Using cached data (no new readings)`);
          }
        } else {
          fetchedData[unitId] = lastKnownData[unitId] || null;
          console.log(`Unit ${unitId}: Using cached data (empty response)`);
        }
      } catch (error) {
        console.error(`Error fetching data for ${unitId}:`, error);
        fetchedData[unitId] = lastKnownData[unitId] || null;
        console.log(`Unit ${unitId}: Using cached data (fetch error)`);
      }
    }

    // Track no-data situations
    if (hasNewData) {
      hideNoDataNotification();
      saveCachedData();
      lastUpdate = Date.now();
      consecutiveNoDataCount = 0;
    } else {
      consecutiveNoDataCount++;
      console.log(`ðŸ“­ No new data received (attempt ${consecutiveNoDataCount}/${NO_DATA_THRESHOLD})`);
      
      if (consecutiveNoDataCount >= NO_DATA_THRESHOLD) {
        showNoDataNotification();
      }
    }

    const maxPoints = 24;
    let allTimestamps = new Set();
    unitIds.forEach(unitId => {
      if (fetchedData[unitId]) {
        Object.keys(fetchedData[unitId]).forEach(ts => {
          const alignedTs = alignTimestamp(ts);
          allTimestamps.add(alignedTs);
        });
      }
    });

    const timestamps = Array.from(allTimestamps).sort().slice(-maxPoints);
    const timeLabels = timestamps.map(formatTimestamp);

    // Initialize charts if needed
    initCharts(unitIds);
    if (Object.keys(carouselCharts).length === 0 && unitIds.length > 0) {
      initCarouselCharts(unitIds);
    }

    // Update regular charts (if they exist in the page)
    for (const chartKey in charts) {
      const chart = charts[chartKey];
      const existingLabels = chart.data.labels;
      
      const newTimestamps = timestamps.filter(ts => {
        const formattedTs = formatTimestamp(ts);
        return !existingLabels.includes(formattedTs);
      });
      
      if (newTimestamps.length > 0 || existingLabels.length === 0) {
        chart.data.labels = timeLabels;
        
        chart.data.datasets.forEach((dataset, unitIndex) => {
          const newData = [];
          timestamps.forEach(alignedTs => {
            const unitId = unitIds[unitIndex];
            if (!fetchedData[unitId]) {
              newData.push(null);
              return;
            }
            
            let foundData = null;
            for (const originalTs in fetchedData[unitId]) {
              if (alignTimestamp(originalTs) === alignedTs) {
                foundData = fetchedData[unitId][originalTs];
                break;
              }
            }
            
            if (!foundData) {
              newData.push(null);
              return;
            }
            
            const metricSuffix = unitId.split('_').pop();
            
            let value = null;
            if (chartKey === 'phChart') {
              value = foundData[`ph_${metricSuffix}`] ?? null;
            } else if (chartKey === 'tempChart') {
              value = foundData[`temperature_${metricSuffix}`] ?? null;
            } else if (chartKey === 'turbChart') {
              value = foundData[`turbidity_${metricSuffix}`] ?? null;
            } else if (chartKey === 'tdsChart') {
              value = foundData[`tds_${metricSuffix}`] ?? null;
            }
            
            newData.push(typeof value === 'number' && !isNaN(value) ? value : null);
          });
          
          dataset.data = newData.slice(-24);
        });
        
        if (chart.data.labels.length > 24) {
          chart.data.labels = chart.data.labels.slice(-24);
        }
      }
      chart.update();
    }

    // Update carousel charts
    if (Object.keys(carouselCharts).length > 0) {
      updateCarouselCharts(unitIds, timestamps, fetchedData);
    }

    const latestReadings = {};
    
    unitIds.forEach(unitId => {
      if (!fetchedData[unitId]) return;
      
      const unitTimestamps = Object.keys(fetchedData[unitId]).sort();
      if (unitTimestamps.length === 0) return;
      
      const latestTs = unitTimestamps[unitTimestamps.length - 1];
      const data = fetchedData[unitId][latestTs] || {};
      const metricSuffix = unitId.split('_').pop();
      
      latestReadings[unitId] = {
        ph: data[`ph_${metricSuffix}`] ?? null,
        temp: data[`temperature_${metricSuffix}`] ?? null,
        turb: data[`turbidity_${metricSuffix}`] ?? null,
        tds: data[`tds_${metricSuffix}`] ?? null,
        timestamp: latestTs
      };
    });

    // Update carousel sensor cards
    updateCarouselSensorCards(unitIds, latestReadings);

    const alertContainer = document.getElementById('reading-alerts');
    alertContainer.innerHTML = '';

    const limits = {
      ph: { min: 6.5, max: 8.5 },
      temp: { min: 15, max: 35 },
      turb: { max: 5 },
      tds: { max: 500 }
    };

    const markerLocations = [];

    unitIds.forEach(unitId => {
      const latest = latestReadings[unitId] || {};
      const { ph, temp, turb, tds, timestamp } = latest;
      const unitName = unitMetadata[unitId]?.name || unitId;

      const isStale = isStaleTimestamp(timestamp);

      const issues = [];
      
      const unitHasData = fetchedData[unitId] !== null && fetchedData[unitId] !== undefined;
      const unitHasValidRecentData = (ph !== null && typeof ph === 'number') ||
                                     (temp !== null && typeof temp === 'number') ||
                                     (turb !== null && typeof turb === 'number') ||
                                     (tds !== null && typeof tds === 'number');

      const usingCachedData = lastKnownData[unitId] && !hasNewData;

      if (!unitHasData) {
        issues.push("ðŸ†• No sensor data received yet");
      } else if (!unitHasValidRecentData) {
        issues.push("âš ï¸ No recent readings available");
      } else {
        if (ph !== null) {
          if (ph < limits.ph.min || ph > limits.ph.max) issues.push(`âš ï¸ pH (${ph})`);
        } else {
          issues.push(`â“ pH missing`);
        }

        if (temp !== null) {
          if (temp < limits.temp.min || temp > limits.temp.max) issues.push(`ðŸŒ¡ï¸ Temp (${temp}Â°C)`);
        } else {
          issues.push(`â“ Temp missing`);
        }

        if (turb !== null) {
          if (turb > limits.turb.max) issues.push(`ðŸ’¦ Turbidity (${turb} NTU)`);
        } else {
          issues.push(`â“ Turbidity missing`);
        }

        if (tds !== null) {
          if (tds > limits.tds.max) issues.push(`ðŸ§‚ TDS (${tds} ppm)`);
        } else {
          issues.push(`â“ TDS missing`);
        }
        
        if (isStale) {
          issues.push(`â° Data is stale (>30 min old)`);
        }
      }

      const allGood = issues.length === 0 && unitHasValidRecentData && !isStale;
      const isNewUnit = !unitHasData;
      const alertType = isNewUnit ? 'alert-info' : (allGood ? 'alert-success' : 'alert-danger');
      
      let alertMessage = '';
      if (isNewUnit) {
        alertMessage = 'ðŸ†• New unit awaiting first sensor data.';
      } else if (!unitHasValidRecentData) {
        alertMessage = 'âš ï¸ No recent data available. Sensor may be offline.';
      } else if (allGood) {
        alertMessage = usingCachedData ? 'âœ… All readings normal (cached)' : 'âœ… All readings normal';
      } else {
        alertMessage = usingCachedData ? 'âš ï¸ Issues detected (cached):' : 'âš ï¸ Issues detected:';
      }

      const lastReadingTime = timestamp ? formatTimestamp(timestamp) : 'Unknown';
      
      const issuesDisplay = issues.length > 0 && unitHasValidRecentData 
        ? `<div class="mt-2 mb-0">${issues.join('<br>')}</div>` 
        : '';
      
      const alertHTML = `
        <div class="alert ${alertType} alert-dismissible fade show" role="alert">
          <strong>${unitName}</strong> â€” ${alertMessage}
          ${issuesDisplay}
          <small class="d-block mt-2">
            <strong>Last reading:</strong> ${lastReadingTime}
            ${usingCachedData ? ' <span class="badge bg-secondary">Cached</span>' : ''}
            ${isStale ? ' <span class="badge bg-warning text-dark">Stale</span>' : ''}
          </small>
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
      `;
      alertContainer.innerHTML += alertHTML;

      if (unitMetadata[unitId] && unitMetadata[unitId].latitude && unitMetadata[unitId].longitude) {
        markerLocations.push({
          lat: unitMetadata[unitId].latitude,
          lng: unitMetadata[unitId].longitude,
          name: unitName,
          description: unitMetadata[unitId].description || 'No description',
          hasAlert: !allGood && unitHasValidRecentData
        });
      }
    });

    updateMapMarkers(markerLocations);

  } catch (error) {
    console.error("Error fetching data:", error);
    const alertContainer = document.getElementById('reading-alerts');
    alertContainer.innerHTML = `
      <div class="alert alert-warning alert-dismissible fade show" role="alert">
        <strong>Connection Issue:</strong> Could not fetch new data. Displaying last known readings if available.
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      </div>
    `;
    
    if (Object.keys(lastKnownData).length > 0) {
      console.log('ðŸ“¦ Attempting to display cached data after error');
    }
  }
}

const map = L.map('map', {
  center: [14.1127855, 121.5584579],
  zoom: 15,
  zoomControl: true,
  dragging: true,
  scrollWheelZoom: true,
  doubleClickZoom: true,
  boxZoom: true,
  touchZoom: true
});

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
  attribution: '&copy; OpenStreetMap contributors' 
}).addTo(map);

// REMOVED: Static markers array and forEach loop that was adding static markers

let dynamicMarkers = [];

function updateMapMarkers(locations) {
  dynamicMarkers.forEach(marker => map.removeLayer(marker));
  dynamicMarkers = [];

  const allBounds = [];

  // REMOVED: Adding static markers to bounds

  locations.forEach(loc => {
    const iconUrl = loc.hasAlert 
      ? 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png'
      : 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png';
    
    const customIcon = L.icon({
      iconUrl: iconUrl,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    const marker = L.marker([loc.lat, loc.lng], { icon: customIcon })
      .addTo(map)
      .bindPopup(`ðŸ“ <b>${loc.name}</b><br>${loc.description}<br><span class="badge ${loc.hasAlert ? 'bg-danger' : 'bg-success'}">${loc.hasAlert ? 'Alert' : 'Normal'}</span>`);
    
    dynamicMarkers.push(marker);
    allBounds.push([loc.lat, loc.lng]);
  });

  if (allBounds.length > 0) {
    map.fitBounds(allBounds, { padding: [50, 50], maxZoom: 16 });
  }
}

window.addEventListener('offline', () => {
  const alertContainer = document.getElementById('reading-alerts');
  alertContainer.innerHTML = `
    <div class="alert alert-warning alert-dismissible fade show" role="alert">
      âš ï¸ <strong>Offline Mode:</strong> You are currently offline. Showing last cached readings.
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
  ` + alertContainer.innerHTML;
  console.log('ðŸ“´ Offline: Using cached data');
});

window.addEventListener('online', () => {
  console.log('ðŸ“¶ Back online: Fetching fresh data');
  fetchData();
});

loadCachedData();

dbRef.on('value', (snapshot) => {
  const now = Date.now();
  if (now - lastUpdate > UPDATE_COOLDOWN) {
    console.log("ðŸ”¥ Firebase data changed â€” updating dashboard (throttled)");
    fetchData();
    lastUpdate = now;
  } else {
    console.log(`â³ Update throttled. Next update in ${Math.ceil((UPDATE_COOLDOWN - (now - lastUpdate)) / 1000)}s`);
  }
});

window.addEventListener('load', () => {
  const carouselSection = document.getElementById('main-carousel-section');
  if (carouselSection) {
    carouselSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Force immediate data fetch for carousel
  console.log('ðŸ”„ Forcing immediate data fetch for carousel...');
  setTimeout(() => {
    fetchData();
  }, 1000);
});

// Update active navigation button
const carouselElement = document.getElementById('waterQualityCarousel');
if (carouselElement) {
  carouselElement.addEventListener('slide.bs.carousel', function(e) {
    const buttons = document.querySelectorAll('.carousel-nav-btn');
    buttons.forEach((btn, index) => {
      if (index === e.to) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  });
}
</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
console.log('ðŸ” DEBUG: Checking what data exists...');

setTimeout(() => {
  console.log('ðŸ“¦ Cached data:', lastKnownData);
  console.log('ðŸ“‹ Unit metadata:', unitMetadata);
  
  console.log('ðŸ”„ Forcing fresh data fetch...');
  fetchData();
}, 3000);
</script>

<!-- The carousel container code remains exactly the same -->
<div class="sticky-carousel-container minimized" id="carousel-container">
  <div class="carousel-header" id="carousel-header-toggle" role="button" aria-expanded="false" tabindex="0">
    <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
      <span class="live-indicator" aria-hidden="true"></span>
      <span class="carousel-title">LIVE READINGS</span>
      <div class="last-updated" id="last-updated" aria-live="polite">
        <span class="refresh-spinner" aria-hidden="true"></span>
        <span id="update-text">Checking...</span>
      </div>
    </div>
    <div class="controls" aria-label="Carousel controls">
      <button class="nav-btn" id="carousel-prev" aria-label="Previous station">&larr;</button>
      <span class="page-indicator" id="page-indicator" aria-live="polite" aria-atomic="true">0 / 0</span>
      <button class="nav-btn" id="carousel-next" aria-label="Next station">&rarr;</button>
      <button class="nav-btn" id="minimize-btn" aria-label="Toggle carousel visibility" title="Minimize/Maximize">âˆ’</button>
    </div>
  </div>

  <div class="carousel-wrapper" id="carousel-wrapper" role="region" aria-label="Water quality monitoring stations">
    <div class="carousel-track" id="carousel-track">
      <div class="carousel-loading" id="carousel-loading" role="status" aria-live="polite">
        <svg width="18" height="18" viewBox="0 0 38 38" xmlns="http://www.w3.org/2000/svg" stroke="#5b6b84" aria-hidden="true">
          <g fill="none" fill-rule="evenodd">
            <g transform="translate(1 1)" stroke-width="2">
              <circle stroke-opacity=".2" cx="18" cy="18" r="18"/>
              <path d="M36 18c0-9.94-8.06-18-18-18">
                <animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.9s" repeatCount="indefinite"/>
              </path>
            </g>
          </g>
        </svg>
        <span>Loading water quality data...</span>
      </div>
    </div>
  </div>
  
  <div class="sr-only" role="status" aria-live="polite" aria-atomic="true" id="screen-reader-announcements"></div>
</div>

<!-- The carousel JavaScript code remains exactly the same -->
<script>
/* Enhanced carousel with all improvements */
(function () {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIGURATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const CONFIG = {
    AUTO_INTERVAL_MS: 7000,
    REFRESH_INTERVAL_MS: 30000,
    STALE_THRESHOLD_MS: 30 * 60 * 1000,
    INTERACTION_PAUSE_MS: 2200,
    SWIPE_THRESHOLD_PX: 80,
    MAX_RETRIES: 3,
    RETRY_DELAY_MS: 2000,
    CACHE_DURATION_MS: 25000,
    
    SENSOR_THRESHOLDS: {
      ph: { min: 6.5, max: 8.5, unit: '', label: 'pH Level' },
      temp: { min: 15, max: 35, unit: 'Â°C', label: 'Temperature' },
      tds: { max: 500, unit: 'ppm', label: 'TDS' },
      turb: { max: 5, unit: 'NTU', label: 'Turbidity' }
    },
    
    FIREBASE_BASE: 'https://thesis-1bda3-default-rtdb.asia-southeast1.firebasedatabase.app'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DOM REFERENCES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const container = document.getElementById('carousel-container');
  const track = document.getElementById('carousel-track');
  const wrapper = document.getElementById('carousel-wrapper');
  const prevBtn = document.getElementById('carousel-prev');
  const nextBtn = document.getElementById('carousel-next');
  const pageIndicator = document.getElementById('page-indicator');
  const minimizeBtn = document.getElementById('minimize-btn');
  const headerToggle = document.getElementById('carousel-header-toggle');
  const loadingEl = document.getElementById('carousel-loading');
  const updateText = document.getElementById('update-text');
  const srAnnouncements = document.getElementById('screen-reader-announcements');

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STATE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let pages = [];
  let currentPage = 0;
  let totalPages = 0;
  let autoInterval = null;
  let userInteracting = false;
  let resumeTimer = null;
  let lastFetchTime = 0;
  let cachedData = null;
  let retryCount = 0;
  let isRefreshing = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UTILITIES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function formatTimestamp(ts) {
    if (!ts) return '--';
    try {
      const [datePart, timePart] = ts.split('_');
      const [y, m, d] = datePart.split('-');
      const [hh, mm] = timePart.split('-');
      return `${y}-${m}-${d} ${hh}:${mm}`;
    } catch (e) {
      return '--';
    }
  }

  function isStale(ts) {
    if (!ts) return true;
    try {
      const [datePart, timePart] = ts.split('_');
      const [y, m, d] = datePart.split('-');
      const [hh, mm] = timePart.split('-');
      const t = new Date(y, parseInt(m) - 1, d, hh, mm);
      return (Date.now() - t.getTime()) > CONFIG.STALE_THRESHOLD_MS;
    } catch (e) {
      return true;
    }
  }

  function safeNum(v) {
    return (typeof v === 'number' && !isNaN(v)) ? v : null;
  }

  function sensorStatus(val, type) {
    if (val === null) return 'missing';
    const threshold = CONFIG.SENSOR_THRESHOLDS[type];
    if (!threshold) return 'missing';
    
    if (threshold.min !== undefined && threshold.max !== undefined) {
      return (val >= threshold.min && val <= threshold.max) ? 'good' : 'bad';
    }
    if (threshold.max !== undefined) {
      return val <= threshold.max ? 'good' : 'bad';
    }
    return 'missing';
  }

  function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, (m) => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[m]));
  }

  function announceToScreenReader(message) {
    srAnnouncements.textContent = message;
    setTimeout(() => { srAnnouncements.textContent = ''; }, 1000);
  }

  function triggerHaptic() {
    if ('vibrate' in navigator) {
      navigator.vibrate(10);
    }
  }

  function updateLastUpdatedDisplay() {
    if (lastFetchTime) {
      const elapsed = Math.floor((Date.now() - lastFetchTime) / 1000);
      if (elapsed < 60) {
        updateText.textContent = `Updated ${elapsed}s ago`;
      } else {
        updateText.textContent = `Updated ${Math.floor(elapsed / 60)}m ago`;
      }
    } else {
      updateText.textContent = 'Checking...';
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DOM CREATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function createBarangayPage(name, desc, ts, sensors) {
    const page = document.createElement('div');
    page.className = 'barangay-page';
    const stale = isStale(ts);
    const hasAlert = sensors.some(s => s.status === 'bad');

    const left = document.createElement('div');
    left.className = 'barangay-card ' + (stale ? 'stale' : '') + (hasAlert ? ' alert' : '');
    left.setAttribute('role', 'article');
    left.setAttribute('aria-label', `${name} water quality station`);
    
    let alertBadge = '';
    if (hasAlert) {
      const alertCount = sensors.filter(s => s.status === 'bad').length;
      alertBadge = `<span class="alert-badge" role="status">âš  ${alertCount} Alert${alertCount > 1 ? 's' : ''}</span>`;
    }
    
    left.innerHTML = `
      <div>
        <h4>${escapeHtml(name)}</h4>
        <p>${escapeHtml(desc || '')}</p>
        ${alertBadge}
      </div>
      <div class="barangay-timestamp">
        <span class="timestamp-label">Last Reading</span>
        <span class="timestamp-value ${stale ? 'stale' : ''}" ${stale ? 'aria-label="Data is stale"' : ''}>${formatTimestamp(ts)}</span>
      </div>
    `;

    const grid = document.createElement('div');
    grid.className = 'sensors-grid';
    grid.setAttribute('role', 'list');
    grid.setAttribute('aria-label', 'Sensor readings');

    sensors.forEach(s => {
      const card = document.createElement('div');
      card.className = 'compact-sensor-card ' + s.status;
      card.setAttribute('role', 'listitem');
      
      let ariaLabel = `${s.label}: `;
      if (s.status === 'missing') {
        ariaLabel += 'no data';
      } else if (s.status === 'bad') {
        ariaLabel += `${s.display} ${s.unit}, alert level`;
      } else {
        ariaLabel += `${s.display} ${s.unit}, normal`;
      }
      card.setAttribute('aria-label', ariaLabel);
      
      card.innerHTML = `
        <div class="sensor-label-compact">${escapeHtml(s.label)}</div>
        <div class="sensor-value-compact">${s.display}</div>
        <div class="sensor-unit-compact">${s.unit || ''}</div>
      `;
      grid.appendChild(card);
    });

    page.appendChild(left);
    page.appendChild(grid);
    return page;
  }

  function createErrorState(message, details) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'carousel-error';
    errorDiv.setAttribute('role', 'alert');
    errorDiv.innerHTML = `
      <svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
      </svg>
      <div class="error-message">${escapeHtml(message)}</div>
      <div class="error-details">${escapeHtml(details)}</div>
      <button class="retry-btn" id="retry-fetch">Retry Now</button>
    `;
    return errorDiv;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RENDERING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function renderPages(pageEls, isError = false) {
    track.innerHTML = '';
    
    if (isError || !pageEls || !pageEls.length) {
      if (isError) {
        track.appendChild(pageEls);
      } else {
        track.appendChild(loadingEl);
      }
      totalPages = 0;
      currentPage = 0;
      updateNav();
      return;
    }

    pageEls.forEach(p => track.appendChild(p));
    totalPages = pageEls.length;
    if (currentPage >= totalPages) currentPage = 0;
    updateTransform();
    updateNav();
  }

  function updateTransform() {
    track.style.transform = `translateX(${-currentPage * 100}%)`;
    pageIndicator.textContent = `${Math.max(1, currentPage + 1)} / ${Math.max(1, totalPages)}`;
    updateNav();
    
    if (totalPages > 0) {
      announceToScreenReader(`Showing station ${currentPage + 1} of ${totalPages}`);
    }
  }

  function updateNav() {
    prevBtn.disabled = currentPage === 0 || totalPages === 0;
    nextBtn.disabled = currentPage >= totalPages - 1 || totalPages === 0;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• AUTO-SCROLL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function startAuto() {
    if (autoInterval || totalPages <= 1) return;
    autoInterval = setInterval(() => {
      if (userInteracting) return;
      currentPage = (currentPage + 1) % totalPages;
      updateTransform();
    }, CONFIG.AUTO_INTERVAL_MS);
  }

  function stopAuto() {
    if (autoInterval) {
      clearInterval(autoInterval);
      autoInterval = null;
    }
  }

  function pauseAutoForInteraction() {
    userInteracting = true;
    stopAuto();
    clearTimeout(resumeTimer);
    resumeTimer = setTimeout(() => {
      userInteracting = false;
      startAuto();
    }, CONFIG.INTERACTION_PAUSE_MS);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DATA FETCHING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  async function fetchWithRetry(url, retries = CONFIG.MAX_RETRIES) {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      } catch (err) {
        if (i === retries - 1) throw err;
        await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY_MS * (i + 1)));
      }
    }
  }

  async function fetchCarouselData(forceRefresh = false) {
    // Use cache if recent
    if (!forceRefresh && cachedData && (Date.now() - lastFetchTime) < CONFIG.CACHE_DURATION_MS) {
      renderPages(cachedData);
      return;
    }

    try {
      isRefreshing = true;
      container.classList.add('refreshing');
      loadingEl.style.display = 'flex';
      updateText.textContent = 'Refreshing...';

      // Fetch metadata
      const metadata = await fetchWithRetry(`${CONFIG.FIREBASE_BASE}/unitsMetadata.json`);
      if (!metadata || typeof metadata !== 'object') {
        throw new Error('Invalid metadata format');
      }

      const unitIds = Object.keys(metadata).sort();
      if (!unitIds.length) {
        renderPages([]);
        lastFetchTime = Date.now();
        updateLastUpdatedDisplay();
        return;
      }

      // Fetch all units in parallel
      const unitPromises = unitIds.map(async uid => {
        try {
          const raw = await fetchWithRetry(`${CONFIG.FIREBASE_BASE}/${uid}.json`);
          return { uid, raw, meta: metadata[uid] };
        } catch (err) {
          console.warn('Unit fetch failed', uid, err);
          return { uid, raw: null, meta: metadata[uid] };
        }
      });

      const results = await Promise.all(unitPromises);
      const newPages = [];
      let alertCount = 0;

      // Process results
      for (const { uid, raw, meta } of results) {
        const suffix = uid.split('_').pop();
        const name = meta?.name || uid;
        const desc = meta?.description || '';

        if (!raw || typeof raw !== 'object') {
          // Missing data page
          const sensors = Object.keys(CONFIG.SENSOR_THRESHOLDS).map(type => ({
            label: CONFIG.SENSOR_THRESHOLDS[type].label,
            display: '--',
            unit: CONFIG.SENSOR_THRESHOLDS[type].unit,
            status: 'missing'
          }));
          newPages.push(createBarangayPage(name, desc, null, sensors));
          continue;
        }

        const timestamps = Object.keys(raw)
          .filter(k => /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}$/.test(k))
          .sort();

        if (!timestamps.length) {
          const sensors = Object.keys(CONFIG.SENSOR_THRESHOLDS).map(type => ({
            label: CONFIG.SENSOR_THRESHOLDS[type].label,
            display: '--',
            unit: CONFIG.SENSOR_THRESHOLDS[type].unit,
            status: 'missing'
          }));
          newPages.push(createBarangayPage(name, desc, null, sensors));
          continue;
        }

        const latest = timestamps[timestamps.length - 1];
        const data = raw[latest] || {};

        const sensors = Object.entries(CONFIG.SENSOR_THRESHOLDS).map(([type, config]) => {
          const key = `${type === 'temp' ? 'temperature' : type === 'turb' ? 'turbidity' : type}_${suffix}`;
          const val = safeNum(data[key]);
          const status = sensorStatus(val, type);
          
          if (status === 'bad') alertCount++;
          
          return {
            label: config.label,
            display: val === null ? '--' : val.toFixed(type === 'tds' ? 0 : (type === 'ph' ? 2 : 1)),
            unit: config.unit,
            status: status
          };
        });

        newPages.push(createBarangayPage(name, desc, latest, sensors));
      }

      // Sort pages: alerts first, then by name
      newPages.sort((a, b) => {
        const aHasAlert = a.querySelector('.alert-badge') !== null;
        const bHasAlert = b.querySelector('.alert-badge') !== null;
        if (aHasAlert && !bHasAlert) return -1;
        if (!aHasAlert && bHasAlert) return 1;
        return 0;
      });

      if (!newPages.length) {
        renderPages([]);
      } else {
        pages = newPages;
        cachedData = newPages;
        renderPages(pages);
        container.classList.remove('minimized');
        
        if (alertCount > 0) {
          announceToScreenReader(`Alert: ${alertCount} sensor${alertCount > 1 ? 's' : ''} outside normal range`);
        }
      }

      lastFetchTime = Date.now();
      retryCount = 0;
      updateLastUpdatedDisplay();

    } catch (err) {
      console.error('Carousel fetch error', err);
      retryCount++;
      
      const errorEl = createErrorState(
        'Unable to load water quality data',
        retryCount >= CONFIG.MAX_RETRIES 
          ? 'Please check your connection and try again' 
          : `Retrying... (${retryCount}/${CONFIG.MAX_RETRIES})`
      );
      
      renderPages(errorEl, true);
      
      // Auto-retry with exponential backoff
      if (retryCount < CONFIG.MAX_RETRIES) {
        setTimeout(() => fetchCarouselData(true), CONFIG.RETRY_DELAY_MS * retryCount);
      }
      
      announceToScreenReader('Error loading data');
    } finally {
      isRefreshing = false;
      container.classList.remove('refreshing');
      loadingEl.style.display = 'none';
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EVENT HANDLERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  prevBtn.addEventListener('click', () => {
    if (currentPage > 0) {
      currentPage--;
      updateTransform();
      pauseAutoForInteraction();
      triggerHaptic();
    }
  });

  nextBtn.addEventListener('click', () => {
    if (currentPage < totalPages - 1) {
      currentPage++;
      updateTransform();
      pauseAutoForInteraction();
      triggerHaptic();
    }
  });

  minimizeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const isMinimized = container.classList.toggle('minimized');
    headerToggle.setAttribute('aria-expanded', String(!isMinimized));
    minimizeBtn.textContent = isMinimized ? '+' : 'âˆ’';
    minimizeBtn.setAttribute('aria-label', isMinimized ? 'Expand carousel' : 'Minimize carousel');
    announceToScreenReader(isMinimized ? 'Carousel minimized' : 'Carousel expanded');
  });

  headerToggle.addEventListener('click', (e) => {
    if (e.target.closest('.nav-btn') || e.target.closest('#minimize-btn')) return;
    const isMinimized = container.classList.toggle('minimized');
    headerToggle.setAttribute('aria-expanded', String(!isMinimized));
    minimizeBtn.textContent = isMinimized ? '+' : 'âˆ’';
    announceToScreenReader(isMinimized ? 'Carousel minimized' : 'Carousel expanded');
  });

  headerToggle.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      headerToggle.click();
    }
  });

  // Drag / swipe
  let startX = null, isDown = false, currentTranslate = 0;
  
  wrapper.addEventListener('pointerdown', (e) => {
    startX = e.clientX;
    isDown = true;
    currentTranslate = -currentPage * wrapper.offsetWidth;
    track.classList.add('dragging');
    pauseAutoForInteraction();
  }, { passive: true });

  window.addEventListener('pointerup', (e) => {
    if (!isDown) return;
    isDown = false;
    track.classList.remove('dragging');
    
    const dx = startX - e.clientX;
    if (Math.abs(dx) > CONFIG.SWIPE_THRESHOLD_PX) {
      if (dx > 0 && currentPage < totalPages - 1) {
        currentPage++;
        triggerHaptic();
      } else if (dx < 0 && currentPage > 0) {
        currentPage--;
        triggerHaptic();
      }
      updateTransform();
    }
  });

  wrapper.addEventListener('pointermove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const dx = e.clientX - startX;
    const translate = currentTranslate + dx;
    track.style.transform = `translateX(${translate}px)`;
  }, { passive: false });

  // Keyboard
  container.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' && currentPage > 0) {
      e.preventDefault();
      currentPage--;
      updateTransform();
      pauseAutoForInteraction();
    }
    if (e.key === 'ArrowRight' && currentPage < totalPages - 1) {
      e.preventDefault();
      currentPage++;
      updateTransform();
      pauseAutoForInteraction();
    }
    if (e.key === 'Home') {
      e.preventDefault();
      currentPage = 0;
      updateTransform();
      pauseAutoForInteraction();
    }
    if (e.key === 'End') {
      e.preventDefault();
      currentPage = totalPages - 1;
      updateTransform();
      pauseAutoForInteraction();
    }
  });

  // Retry button (delegated)
  track.addEventListener('click', (e) => {
    if (e.target.id === 'retry-fetch') {
      retryCount = 0;
      fetchCarouselData(true);
    }
  });

  // Tab visibility
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      stopAuto();
    } else {
      startAuto();
      // Refresh data if stale
      if (Date.now() - lastFetchTime > CONFIG.CACHE_DURATION_MS) {
        fetchCarouselData(true);
      }
    }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INITIALIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  fetchCarouselData().then(() => {
    if (pages.length > 1) startAuto();
  });

  // Periodic refresh
  setInterval(() => {
    if (!document.hidden && !isRefreshing) {
      fetchCarouselData(true);
    }
  }, CONFIG.REFRESH_INTERVAL_MS);

  // Update "last updated" display every 10s
  setInterval(updateLastUpdatedDisplay, 10000);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PUBLIC API â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window._sc_carousel = {
    refresh: () => fetchCarouselData(true),
    goto: (n) => {
      if (n >= 0 && n < totalPages) {
        currentPage = n;
        updateTransform();
        pauseAutoForInteraction();
      }
    },
    minimize: () => {
      container.classList.add('minimized');
      headerToggle.setAttribute('aria-expanded', 'false');
      minimizeBtn.textContent = '+';
    },
    expand: () => {
      container.classList.remove('minimized');
      headerToggle.setAttribute('aria-expanded', 'true');
      minimizeBtn.textContent = 'âˆ’';
    },
    getConfig: () => CONFIG,
    getStats: () => ({
      totalPages,
      currentPage,
      lastFetchTime,
      retryCount,
      isRefreshing,
      cacheAge: Date.now() - lastFetchTime
    })
  };
})();
</script>

</body>
</html>